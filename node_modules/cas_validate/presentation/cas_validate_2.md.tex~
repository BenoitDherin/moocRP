\section[a-node.js-module-for-cas]{A node.js module for CAS}

\section[hello-my-name-is-james]{Hello, my name is James}

\startitemize[packed]
\item
  Transportation engineering PhD
\item
  Research scientist with UCI ITS
\item
  https://github.com/jmarca
\item
  http://contourline.wordpress.com
\item
  james@activimetrics.com
\stopitemize

\thinrule

{\externalfigure[figs/lavender_2.jpg]}\crlf
 ------------------------------

\section[cas]{CAS}

I don't know anything about CAS internals.

This talk is about {\em using} CAS

\section[use-case-cas-ldap]{Use case: CAS + ldap}

\startitemize[packed]
\item
  Used to use Drupal
\item
  Drupal was set up to use ldap and CAS
\item
  So we used ldap and CAS
\stopitemize

\section[single-sign-on-single-sign-off]{Single sign on, single sign
off}

\startitemize[packed]
\item
  Caltrans sponsors liked the website, but
\item
  They didn't like signing in again to project sites
\item
  Need single sign on, sign off
\stopitemize

\section[i-use-node.js]{I use node.js}

\startitemize[packed]
\item
  JavaScript on the server.
\item
  Fast because V8 is fast
\item
  Clean, single-threaded non-blocking design
\item
  What's not to like?
\stopitemize

\section[cas-support-in-node.js]{CAS support in node.js}

\startitemize[packed]
\item
  The node.js packaging system is npm.
\item
  \type{npm search cas}: lots of options
\item
  but none supported single sign out
\stopitemize

\section[cas-validate]{CAS Validate}

\startitemize[packed]
\item
  repository: https://github.com/jmarca/cas_validate
\item
  installation: npm install cas_validate
\item
  a plugin to
  \useURL[url1][http://www.expressjs.com/][][Express]\from[url1] and
  \useURL[url2][http://senchalabs.github.com/connect/][][Connect]\from[url2]
\stopitemize

\section[node.js-idioms]{Node.js idioms}

\subsection[a-brief-digression]{A brief digression}

\section[non-blocking-by-design]{Non-blocking by design}

\startitemize[packed]
\item
  file i/o
\item
  web operations
\item
  db access
\item
  etc
\stopitemize

\section[async-needs-callbacks]{Async needs callbacks}

\type{fs.readFile(filename, [encoding], [callback])}

Asynchronously reads the entire contents of a file:

\starttyping
fs.readFile('/etc/passwd', function (err, data) {
  if (err) throw err;
  console.log(data);
});
\stoptyping

\section[functionerr-data]{function(err, data)}

The callback is passed two arguments \type{(err, data)}. Check for
errors, then handle \type{data}.

\section[callback-is-the-last-argument]{callback is the last argument}

example from node-redis code

\thinrule

\starttyping
RedisClient.prototype.send_command =
       function (command, args, callback) {
    if (Array.isArray(args)) {
        if (typeof callback === "function") {
        } else if (! callback) {
            last_arg_type = typeof args[args.length-1];
            if (last_arg_type === "function"
                || last_arg_type === "undefined") {
                callback = args.pop();
            }
        } else { throw new Error("...");}
    } else { throw new Error("..."); }
}
\stoptyping

\section[closures-are-used]{Closures are used}

\starttyping
var fs = require('fs')
function doSomething(done){
    function callback(err, data) {
        if (err) throw err
        return done(null,data)
    })
    fs.readFile('hpms/data.txt','utf8',
                callback)
}
\stoptyping

\section[end-of-digression]{End of digression}

Except:

\startitemize[packed]
\item
  semicolons are optional
\item
  comma first notation is popular
\stopitemize

\section[program-requirements]{Program requirements}

\startitemize[packed]
\item
  Express is route based
\item
  public routes:
  \startitemize[packed]
  \item
    check if logged in,
  \item
    but don't {\em require} a login.
  \stopitemize
\item
  restricted routes:
  \startitemize[packed]
  \item
    require a login,
  \item
    check permissions, etc
  \stopitemize
\stopitemize

\section[single-sign-onoff]{Single Sign On/Off}

\startitemize[packed]
\item
  A login here=login everywhere
  \startitemize[packed]
  \item
    and vice versa
  \stopitemize
\item
  A logout here=logout everywhere
  \startitemize[packed]
  \item
    and vice versa
  \stopitemize
\stopitemize

\section[cas-documentation-is-excellent]{CAS documentation is excellent}

Thanks

\section[basic-login-task]{Basic login task}

\startitemize[n,packed][stopper=.]
\item
  establish a session with the client
\item
  ask the client to redirect to the CAS server
\item
  expect a reply back from the CAS server with a ticket
\item
  check the ticket's validity directly with the CAS server
\stopitemize

\section[establish-a-session-with-a-client]{Establish a session with a
client}

\startitemize[packed]
\item
  use standard connect/express middleware
\stopitemize

\thinrule

\starttyping
var express = require('express')
var RedisStore =
     require('connect-redis')(express);
var app = express()
app
 .use(express.logger({buffer:5000}))
 .use(express.bodyParser())
 .use(express.cookieParser('tall barley at Waterloo'))
 .use(express.session({ store: new RedisStore }))
\stoptyping

\section[redirect-to-cas-server]{Redirect to CAS server}

\startitemize[packed]
\item
  more complicated, but still easy
\stopitemize

\thinrule

\subsection[prerequisites]{Prerequisites:}

\starttyping
var querystring = require('querystring')
// configurable
var cas_host = 'https://my.cas.host'
var login_service = '/cas/login'
\stoptyping

\thinrule

\starttyping
var redirecter = function (req,res,next){
    // decide endpoint where CAS server
    // will return to
    var service = determine_service(req)
    var queryopts = {'service':service}
    res.writeHead(307,
        { 'location': cas_host+login_service +'?'
               +querystring.stringify(queryopts)
        })
    return res.end()
}
\stoptyping

\section[listen-for-cas-reply]{Listen for CAS reply}

\startitemize[packed]
\item
  parse incoming query for \type{ticket} parameter
\stopitemize

\thinrule

\starttyping
function ticket_check(req,res,next){
    var url = parseUrl(req.url,true);
    if( url.query === undefined
       || url.query.ticket === undefined){
        logger.debug('moving along, no ticket');
        return next(); // next route
    }
    logger.debug('have ticket')
    ...
\stoptyping

\section[check-ticket-validity]{Check ticket validity}

\startblockquote
The request MUST include a valid service ticket, passed as the HTTP
request parameter, \quotation{ticket}.
\stopblockquote

\startitemize[packed]
\item
  Directly connect with CAS server to check validity of ticket
\item
  Using the Request library
\stopitemize

\thinrule

\subsection[prerequisites-1]{Prerequisites:}

\starttyping
var redis = require("redis")
var redclient = redis.createClient();
redclient.on("error", function (err) {
    logger.error("Redis Client Error: " + err);
});
\stoptyping

\thinrule

\starttyping
function ticket_check(req,res,next){
    ...
    var ticket = url.query.ticket;
    var service = opt_service ?
        opt_service : determine_service(req)
    var cas_uri =
       cas_host+validation_service +'?'
       +querystring.stringify({'service':service,
                               'ticket':ticket});
    request({uri:cas_uri}, callback);
    return null;
});
\stoptyping

\section[define-the-request-callback]{Define the request callback}

\startitemize[packed]
\item
  current version uses a regular expression
\item
  development version actually parses the XML
\item
  callback is a defined in ticket_check, can see \type{ticket} and
  \type{next}
\item
  Redis: use Redis to link CAS session ticket and local session
\stopitemize

\thinrule

\starttyping
function callback(err, resp, body) {
    if (!err && resp.statusCode === 200) {
        if(/cas:authenticationSuccess/.exec(body)){
            if(/<cas:user>(\w+)<\/cas:user>/.exec(body)){
                req.session.name = RegExp.$1;
            }
            req.session.st = ticket;
            redclient.set(ticket,req.sessionID);
            return next();
        }else{  next(new Error('authentication failed')); }
    }else{ next(new Error('authentication failed')); }
}
\stoptyping

\section[thats-it]{That's it}

\startitemize[packed]
\item
  We redirected to CAS
\item
  consumed the service ticket
\item
  verified the service ticket
\item
  established a session
\item
  stored the session in Redis with the ticket as the key
\stopitemize

\thinrule

\section[example-server]{Example server}

\thinrule

\starttyping
var app = express()
.use(express.cookieParser('barley Waterloo Napoleon'))
.use(express.session({ store: new RedisStore }))
.use(cas_validate.ticket({'cas_host':cas_host}))
.use(cas_validate.check_or_redirect({'cas_host':cas_host}))
.use(function(req, res, next){
         res.end('hello world')
         return null
     });
var server =app.listen(testport,testhost,done)
\stoptyping

\thinrule

\section[single-sign-off]{Single Sign Off}

\startitemize[packed]
\item
  very easy
\item
  listen for a \type{POST} from the CAS server
\item
  invalidate the session
\stopitemize

\thinrule

\starttyping
function ssoff(req,res,next){
   var method = req.method.toLowerCase();
   if (method == 'post'){
       return invalidate(req,res,next);
   }
   return next()
}
\stoptyping

\thinrule

\starttyping
function invalidate(req,res,next){
      var st = get_session_ticket(req)
      redclient.get(st,function(err,sid){
          req.sessionStore.destroy(sid
          ,function(err){
              redclient.del(st);
              return null
          }});
      res.end();
      return null;
  }
}
\stoptyping

\thinrule

\section[demo-1]{Demo 1}

Sign on

\thinrule

\section[demo-2]{Demo 2}

Sign off

\thinrule

\section[ctmlabs-banner]{CTMLabs banner}

\startitemize[packed]
\item
  Using this library to create a dynamic banner for our sites
\item
  Researchers need only write
\stopitemize

\starttyping
<script src='http://menu.ctmlabs.net/menu.js?resetgateway=true&service=http%3a%2f%2fara.ctmlabs.net%2findex.html'></script>
\stoptyping

\useURL[url3][http://ara.ctmlabs.net][][\hyphenatedurl{http://ara.ctmlabs.net}]\from[url3]

\thinrule

\section[thank-you]{Thank you}

Questions? Comments? Rotten tomatoes?

\thinrule

\section[gripe]{Gripe}

Is user agent parsing still horribly broken in default CAS server?
