{
  "name": "cas_validate",
  "description": "Interact with a CAS server to validate client interaction",
  "version": "0.1.9",
  "author": {
    "name": "James E. Marca",
    "email": "jmarca@translab.its.uci.edu"
  },
  "license": "MIT",
  "keywords": [
    "cas",
    "central authentication service",
    "authentication"
  ],
  "directories": {
    "lib": "./lib"
  },
  "engines": {
    "node": "*"
  },
  "scripts": {
    "test": "NODE_ENV='test' mocha --timeout 15000 -R list --bail"
  },
  "dependencies": {
    "hiredis": "",
    "redis": "",
    "underscore": "",
    "libxmljs": "",
    "request": "~2.16",
    "winston": ""
  },
  "devDependencies": {
    "mocha": "*",
    "should": "*",
    "connect": "*",
    "connect-redis": "*",
    "express": "*",
    "async": "*"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/jmarca/cas_validate.git"
  },
  "readme": "# CAS Validate\n\nThis is a utility to facilitate validating a web service based on\nConnect or Express (and perhaps other frameworks or nothing at all)\nwith a CAS server(<http://www.jasig.org/cas>.  It allows single sign\non and\n[single sign out](https://wiki.jasig.org/display/CASUM/Single+Sign+Out).\nIn other words, if a client has previously logged in to the CAS\nserver, this library will allow your service to transparently detect\nthat fact, and if the user subsequently logs off from the CAS server,\nthis library can handle the subsequent POST message from the CAS\nserver and log the user out of your service as well.\n\nThe need to support single sign out was the original reason I wrote\nthis library.  Since then I modularized it so that I could apply\ndifferent strategies to different services in my Connect and Express\napplications.  The original development was conducted when Connect\nstill had routing capabilities, but all but one feature still works\nwith the latest Connect, and all features work with Express.\n\n\n# Redis version 2.6\n\nThis library now requires redis version 2.6.x.  I recently added\ntime-to-live capabilities when storing the session ticket data (using\nthe redis setex command as suggested by @chrisbarran).  The test for\nthis functionality (test/ttl_test.js) fails when running Redis 2.4,\nbut passes when running Redis 2.6.\n\n# Version 0.1.9\n\nA minor update to parse attributes in a second way.  According to user\n@cricri's pull request, another way that is common to send user\nattributes to the CAS client is to simply list them.  That is, the way\nI am parsing by default is\n\n```xml\n<cas:serviceResponse xmlns:cas='http://www.yale.edu/tp/cas'>\n\t<cas:authenticationSuccess>\n\t\t<cas:user>h_mueller</cas:user>\n\t\t<cas:attributes>\n\t\t\t\t\t<cas:mail>a.b@c.de</cas:mail>\n\t\t\t\t\t<cas:__AUTHUSERCONTEXT__>cont</cas:__AUTHUSERCONTEXT__>\n\t\t\t\t\t<cas:cn>commonname</cas:cn>\n\t\t\t\t\t<cas:__AUTHTYPE__>TUID</cas:__AUTHTYPE__>\n\t\t\t\t\t<cas:surname>MÃ¼ller</cas:surname>\n\t\t\t\t\t<cas:tudUserUniqueID>1234567</cas:tudUserUniqueID>\n\t\t\t\t\t<cas:givenName>Hans</cas:givenName>\n\t\t</cas:attributes>\n\t</cas:authenticationSuccess>\n</cas:serviceResponse>\n```\n\nbut there is an alternate way that simply lists the attributes as so:\n\n```xml\n<cas:serviceResponse xmlns:cas='http://www.yale.edu/tp/cas'>\n  <cas:authenticationSuccess>\n    <cas:user>bob</cas:user>\n    <cas:attribute name=\"uid\" value=\"b01234\" />\n    <cas:attribute name=\"mail\" value=\"bob@mail.com\" />\n    <cas:attribute name=\"cn\" value=\"smith\" />\n    <cas:attribute name=\"givenname\" value=\"bob\" />\n    <cas:attribute name=\"service\" value=\"other\" />\n    <cas:attribute name=\"permission\" value=\"p1\" />\n    <cas:attribute name=\"permission\" value=\"p2\" />\n    <cas:attribute name=\"permission\" value=\"p3\" />\n    <cas:attribute name=\"uidnumber\" value=\"123456789\" />\n  </cas:authenticationSuccess>\n</cas:serviceResponse>\n```\nVersion 0.1.9 should now properly parse the second way as well,\nwhereas before it would simply choke and die.\n\nCheck out the test in\n\nThis email thread is one that I found when trying to dig up the\n\"standard\" way to send user attributes:\nhttp://jasig.275507.n4.nabble.com/CAS-attributes-and-how-they-appear-in-the-CAS-response-td264272.html\n\n\n# Version 0.1.8\n\nBiggest change here is a switch from SAX parser to XML doc parser for\nparsing the response from the CAS server ticket validation.  It was\nreported that the parser was choking on attributes with umlauts and\nother common utf-8 characters.  Apparently, either the SAX parser\napproach in libxmljs or the way I was using it was to blame, but the\nupshot was that non-ascii characters were getting mangled.\n\nTo fix this, I switched to using the whole-doc parsing approach.  This\nwill use slightly more memory, etc, as the whole DOM tree for the\nresponse has to be loaded into memory, but the docs are small so that\nis probably fine.\n\nThe test that checks this is in `test/xml_parser_test.js`  It does not\nuse a live CAS server, so you can run it on your own and load it up\nwith your own CAS response docs to see whether everything is getting\nparsed okay.  Just replace the file in `test/files/cas_auth.xml` with\nyour own difficult-to-parse case, and then submit a bug report is\nstuff is breaking.\n\n# Version 0.1.0\n\nThis new version brings with it some small API changes for the few\npeople who might be using this.  The major difference is that it is\nno longer optional to pass the service location.  That is, the\nroutines do not try to guess what the service might be from the\nrequest header.  This is because at the Open Apereo 2013 conference,\nit was pointed out during a security audit that doing so is a possible\nsecurity flaw.\n\nSo invoke the various functions as so:\n\n```javascript\napp.use('/valid'\n       ,cas_validate.ticket({'cas_host':my_cas_host,\n                             'service':'http://'+testhost +':'+testport+'/valid'}))\n```\n\nThe other major change in functionality is that the ticket response\nfrom the CAS server is now parsed for attributes.  Unfortunately, this\ncurrently requires an XML response from the CAS server.  I will\nimplement the JSON response handler soon, but in the interim you might\nwant to check out the\n[Sheffield University fork](https://github.com/SheffieldUni/cas_validate)\n\n# Roadmap\n\nI am in the midst of refactoring and modularizing this library.  The\nmost pressing need is to parse a  JSON response  from the CAS server.\nNext comes centralizing the initialization of this library.  For the\nmoment, the best approach is to create an object in your calling code\nthat holds the common CAS initialization attributes.\n\nVersion 0.2.0 will be hit when JSON responses are possible, and\nversion 0.3.0 will be hit when all of the various routines are\nmodularized (so you don't have to delete the SSOFF code, for example,\nyou just don't have to use it)\n\n\n# Example use for a Connect-based server:\n\nUsing the library is pretty easy.  Just add the necessary `require`\nstatement, and then slot in the desired CAS behavior.  For example to\nprevent all access to your application, you would do the following:\n\n```javascript\n\nvar cas_validate = require('cas_validate');\n...\n\nvar app = connect()\n            .use(connect.cookieParser('barley wheat napoleon'))\n            .use(connect.session({ store: new RedisStore }))\n            .use(cas_validate.redirect({'cas_host':'my.cas.host.net'})\n            .use(function(req, res, next){\n                      res.end('hello world')\n                 });\nvar server = app.listen(3000,function(e){\n            if(e) throw new Error(e)\n            console.log('app started on port 3000')\n    });\n);\n```\n\nA few things to note.  First I am using the connect-redis plugin to\nmanage sessions from CAS.  I haven't tested whether other session\nmanagement plugins will work, but as long as they allow simple\noperations such as\n\n    req.session.st = ticket\n\nthey should work fine.\n\nSecond, the `cas_host` option currently just wants the host.  I prepend\n`https://` to this host.  If you aren't using https for your CAS\nserver, then you're out of luck for using this library.\n\n\n# Installation\n\n## Via npm\n\n```bash\n$ cd myapplication\n$ npm install cas_validate\n```\n\nOr you can add it to your package.json dependencies.\n\n\n## Manual install\n\n```bash\n$ cd ~/my/github/repos\n$ git clone git://github.com/jmarca/cas_validate.git\n$ cd myapplication\n$ npm install ~/my/github/repos/cas_validate\n```\n\n\n\n# Exported Functions\n\n## `ticket`\n\nThe `ticket` function is crucial to handling CAS sessions.  It will\nconsume the service ticket from the CAS server, verify that it is\nvalid, establish a valid session on your service for the client, and\nwill store the CAS credentials in a redis database to allow for single\nsign out POST messages.  If there is no service ticket in the request,\nor if the service ticket is not valid, this function will simply pass\ncontrol along to the next connect middleware in the web stack.\n\n### Options\n\n* `cas_host`: the CAS hostname, without the 'https://' part and\n  without the '/cas/login' part.  Something like `cas.example.net`.\n  The default is to read the CAS_HOST environment variable.  This\n  option, if set, will override the default.\n\n* `service`: the service for which the service ticket was issued.  If\n  used in the same route as the `check_...` part of the function, then\n  this parameter can be left to its default, and the correct value\n  will be deduced from the request parameters.  In some cases it might\n  be necessary to specify this value.\n\n## `check_or_redirect`\n\nThe `check_or_redirect` function is probably the most useful one.\nUsed in conjunction with the `ticket` function, it will enable\nCAS-based authentication.\n\n### Options\n\n* `cas_host`: the CAS hostname, without the 'https://' part and\n  without the '/cas/login' part.  Something like `cas.example.net`.\n  The default is to read the CAS_HOST environment variable.  This\n  option, if set, will override the default.\n\n* `service`: the service for which the service ticket will be issued,\n  and to which the CAS server will redirect the request after the user\n  has logged in.  The default is to figure out the service from the\n  incoming request, but one may want to redirect the incoming request\n  somewhere else.\n\n### Example\n\nAn example of redirecting the request to another destination is shown\nbelow, modified from the test suite.\n\n\n```javascript\n\napp = connect()\napp.use(cas_validate.ssoff())\napp.use(cas_validate.ticket({'cas_host':chost}))\napp.use(function(req, res, next){\n            if(req.session.st){\n                return res.end('hello '+req.session.name)\n            }else{\n                return res.end('hello world (not logged in)')\n            }\n        }\n       )\nvar login = connect()\nlogin.use(connect.cookieParser('six foot barley at Waterloo'))\nlogin.use(connect.session({ store: new RedisStore }))\nlogin.use('/login',cas_validate.check_or_redirect({'cas_host':chost\n                                                  ,'service':'http://'+testhost+':'+testport+'/'}))\nlogin.use('/',app)\n\nserver = login.listen(testport,done)\n\n```\n\nIn the above example, the `/login` route will send the user to the CAS\nserver to login, and then return them to the `/` destination.  The\ndefault behavior would be to return them to the `/login` path that\nthey came from.\n\nAlso note that since we don't expect the CAS server to send its ticket\nto the `/login` path, the `ticket` service is not attached to that\nroute.  It is attached to the `/` route, and will consume the ticket\nthere.\n\nAlso also, when the CAS session expires and the CAS server sends a\npost request informing your server of this fact, it will send it to\nthe path listed in the `service` parameter.  So if you only want to\nallow POST requests to a certain address, that is another reason to\nspecify the service parameter.\n\n## `check_and_return`\n\nThe `check_and_return` function is somewhat useful.  The idea is to\nexploit the feature in the CAS server that listens for a\n'gateway=true' parameter in the URL.  This will return a service\nticket if the client has a valid CAS session, and will return nothing\nif not.\n\n### Options\n\nThe same options as `check_or_redirect`, above\n\n### Example\n\nThe previous example has been modified below to use check_and_return\ninstead of check_or_redirect\n\n```javascript\n\napp = connect()\napp.use(cas_validate.ssoff())\napp.use(cas_validate.ticket({'cas_host':chost}))\napp.use(cas_validate.check_and_return({'cas_host':chost\n                                      ,'service':'http://'+testhost+':'+testport+'/'}))\napp.use(function(req, res, next){\n            if(req.session.st){\n                return res.end('hello '+req.session.name)\n            }else{\n                return res.end('hello world (not logged in)')\n            }\n        }\n       )\nvar login = connect()\nlogin.use(connect.cookieParser('six foot barley at Waterloo'))\nlogin.use(connect.session({ store: new RedisStore }))\nlogin.use('/login',cas_validate.check_or_redirect({'cas_host':chost\n                                                  ,'service':'http://'+testhost+':'+testport+'/'}))\nlogin.use('/',app)\n\nserver = login.listen(testport,done)\n\n\n```\n\nIn the previous server, the system would not know whether or not a\nuser was logged in until the user went to the `/login` route and\ntriggered the `check_or_redirect` function.  Here, instead, the `/`\nroute has the `check_and_return` function set.  What happens is that\nthe first time the user goes to the `/` location, the CAS system is\nchecked to see if the user is logged in already.  Internally this sets\na flag in the session, so as to prevent an infinite loop.  If the user\nis logged in already, then the CAS system will respond with a valid\nservice ticket that the `ticket` service will consume.  If the client\nhas not established a CAS login, then there is no ticket sent from\nCAS, and the user is not logged in.\n\nThe problem with this approach is that it does not detect if the user\ngoes to your web application, then logs in to another CAS service.\nOnce the gateway service is checked, it is not checked again.\n\nIf you wish to check the CAS service once with every request, then\nsimply delete the session property `req.session.gateway`.  However, be\naware that until the user logs in properly, resetting\n`req.session.gateway` will cause a redirect through the CAS server\nwith every request, which will greatly slow down the performance of\nyour system.\n\n\n## `redirect`\n\n`redirect` is a somewhat lame filter, but it can be useful.  All it\ndoes is redirect incoming queries to the CAS login page.  Even if the\nsession has been established, it will always ignore that fact and\nbounce the request.\n\n## `ssoff`\n\nThe `ssoff` service will listen for incoming POST messages from the\nCAS server and will delete sessions as appropriate.\n\nDo *not* put this service after the `check_or_redirect` service, or the\nCAS server POSTs will get redirected to the CAS server to log in!\n\n### Options\n\nNo options\n\n### Example\n\n```javascript\n\napp.use(cas_validate.ssoff())\napp.use(cas_validate.ticket())\napp.use(cas_validate.check_or_redirect())\napp.use('/',function(req, res, next){\n          res.end('hello only to the authenticated world')\n});\n\n```\n\n## `logout`\n\nThe `logout` service is similar to single sign off, but does the job\nof invalidating the current session first, before triggering the CAS\nserver's logout function.\n\nYou can use this with the `ssoff` service to enable logging out from\nyour application directly, or indirectly from some other CAS enabled\napp.\n\n### Options\n\n* `cas_host`: the CAS hostname, without the 'https://' part and\n  without the '/cas/logout' part.  Something like `cas.example.net`.\n  The default is to read the CAS_HOST environment variable.  This\n  option, if set, will override the default.\n\n* `service`: the service for which the service ticket will be issued,\n  and to which the CAS server will redirect the request after the user\n  has logged in.  The default is to figure out the service from the\n  incoming request, but one may want to redirect the incoming request\n  somewhere else.\n\n* `logout_service`: the default CAS logout service is `/cas/logout`.\n  If your CAS setup uses a different endpoint, then specify that here.\n\n\n### Example\n\nAs usual, check out the test for a complete example.  Cut and paste below:\n\n```javascript\n\napp = connect()\n    .use(connect.bodyParser())\n      .use(connect.cookieParser('barley Waterloo Napoleon loser'))\n      .use(connect.session({ store: new RedisStore }))\n\napp.use('/username',cas_validate.username)\n\napp.use('/quit',cas_validate.logout({'cas_host':'my.cas.host'\n                                    ,'service':'http://myhost.com'}))\napp.use(cas_validate.ssoff())\napp.use(cas_validate.ticket({'cas_host':'my.cas.host'\n                             ,'service':'http://myhost.com'}))\napp.use(cas_validate.check_and_return({'cas_host':'my.cas.host'\n                                      ,'service':'http://myhost.com'}))\n\napp.use(function(req, res, next){\n            if(req.session.st){\n                return res.end('hello '+req.session.name)\n            }else{\n                return res.end('hello world (not logged in)')\n            }\n        }\n       )\nvar login = connect()\n.use(connect.cookieParser('six foot barley at Waterloo'))\n.use(connect.session({ store: new RedisStore }))\nlogin.use('/login',cas_validate.check_or_redirect({'cas_host':'my.cas.host'\n                                                  ,'service':'http://myhost.com'}))\nlogin.use('/',app)\nserver=login.listen(testport\n                   ,done)\n\n```\n\n\n## `username`\n\nA simple service to spit back the current logged in user's username as\na JSON object, or null.\n\nEither:\n\n```javascript\n\nreturn res.end(JSON.stringify({'user':req.session.name}));\n\n```\n\nor\n\n```javascript\n\nreturn res.end(JSON.stringify({'user':null}));\n\n```\n\n### Options\n\nNo options\n\n\n## `session_or_abort`\n\nThe `session_or_abort` service no longer works with Connect, as\nrouting has been removed.  This is the only feature that requires\nExpress.\n\nThe idea is to abort the current route if a session has not been\nestablished.  This is done by calling `next('route')` within the code\nif the CAS session check fails.\n\nThe intended use case is to assign certain stacks of routes to logged\nin users, and others to those who are not logged in, without having to\nresort to multiple paths or lots of `if` statements in your server\ncode.\n\n### Options\n\nNo options\n\n### Example\n\n```javascript\n\napp = express()\n      .use(connect.cookieParser('barley Waterloo Napoleon Mareschal Foch bravest'))\n      .use(connect.session({ store: new RedisStore }))\n\napp.get('/secrets'\n       ,cas_validate.session_or_abort()\n       ,function(req,res,next){\n            res.end('super secret secrets')\n        })\n\napp.get('/secrets'\n       ,function(req,res,next){\n            res.end('public secrets')\n        })\n\n```\n\n\n# Tests\n\nThe tests provide working examples of how to use the library.\n\nTo run the tests, you need to have a working CAS server, and you need\nto set lots of environment variables.\n\n## Environment variables\n\n* CAS_HOST:  no default.  The CAS host (bare host name or number; not\n  https, not /cas/login)\n\n* CAS_USER:  no default.  Your CAS username you want to use for the\n  tests.\n\n* CAS_PASS: no default.  The password to go along with the CAS\n  username\n\n* CAS_VALIDATE_TEST_URL: Default is '127.0.0.1'.  If you want to test\n  single sign out (the `ssoff` service), then you'll need to run your\n  test server on a public machine, with a URL that the CAS server can\n  send a POST to.  SSOFF tests will be skipped if CAS_VALIDATE_TEST_URL\n  is 127.0.0.1 and the hostname part of CAS_HOST is *not* 127.0.0.1.\n\n* CAS_VALIDATE_TEST_PORT: Default is 3000.  If you are already using\n  port 3000 for something else, change this.  Also, make sure that\n  this port is not blocked in your firewall if you want to test single\n  sign off...otherwise you won't see the POSTs from the CAS server to\n  your test application.\n\nTo run the tests, make sure to first install all of the dependencies\nwith\n\n    npm install\n\nThen run the tests with\n\n    npm test\n\nor\n\n    make test\n\n(I do this to get the nyan cat reporter)\n\nIf you are running on localhost, the last tests related to single sign\noff will be skipped.  The idea is that localhost isn't usually an\naddress that can be hit by another machine, so the test should not be\nrun.\n\nInstead, put the library on a machine with a URL (even a numeric one)\nthat your CAS server can see and send a POST to.  This will more\naccurately model a real production environment.\n\nFor example, if you have a server called `http://awesome.mycompany.net`\nyou can run the test on port 3000 on this machine by typing\n\n```\nexport CAS_VALIDATE_TEST_URL='awesome.mycompany.net'\n```\n\nThen all the tests will run, and they should all pass.  Assuming of\ncourse that you have a properly configured CAS server and identified\nit as noted above.  The only caveat is that waiting for the POST is\nslow, and so the test may timeout.  If this happens, try running with\na longer timeout period (`mocha --timeout 50000 test`)\n\n\n## Testing XML validation functionality\n\nBy default now, if your CAS server returns user attributes as XML,\nthen these attributes will be parsed and loaded into the environment.\n\nAs noted above, the XML parser was switched away from a SAX-style\nparser to a whole document parser, in order to get around a character\nencoding bug.  This change has an accompanying test in\n`test/xml_parser_test.js`, and reads in the two files found in\n`test/files/`, so if you want to test out your own specific case prior\nto deploying this library, swap in your own XML files there.\n\nThe test (`test/parse_casxml_response.js`) is designed explicitly for my case,\nwhere I am passing back `['mail','sn','cn','givenName','groups']` from\nldap via CAS.  If your local CAS server is not passing back these\nthings, then the test will fail for you.  To help, I am dumping to the\nconsole the object returned from parsing.  If it makes sense to you\ngiven your CAS server and given your test user (CAS_USER environment\nvariable), then the test is passing.  Feel free to fork and create a\nmore general test if you can think of one.\n\n\n\n# Logging\n\nThis package uses [winston](https://github.com/flatiron/winston).  Not\nwell, but anyway, there it is.  Basically, if you want lots of output,\nset the `NODE_ENV` environment variable to 'development'.  If you are\nrunning in production, set `NODE_ENV` to 'production'.  This also\nmeshes well with Express usage of the `NODE_ENV` variable.  Finally,\nif something weird is going on in production, you can also set the log\nlevel explicitly, by setting either `CAS_VALIDATE_LOG_LEVEL` or\n`LOGLEVEL` to the usual ['debug','info','warn','error'] (although this\nhasn't been tested)\n\nIn the code noisy alerts are at the debug level, and then errors are\nat the error level, but maybe in the future I'll add finer grained\nmessage levels.\n\n\n\n\n# See Also\n\nThe CAS server is documented at <http://www.jasig.org/cas>.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/jmarca/cas_validate/issues"
  },
  "homepage": "https://github.com/jmarca/cas_validate",
  "_id": "cas_validate@0.1.9",
  "dist": {
    "shasum": "318be08f7f585a094c9e971267260974e680fad2"
  },
  "_from": "cas_validate@latest",
  "_resolved": "https://registry.npmjs.org/cas_validate/-/cas_validate-0.1.9.tgz"
}
